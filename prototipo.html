<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rocket Flight VR - Refactored OOP</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #667eea;
            min-width: 300px;
        }
        .status {
            margin: 8px 0;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
        }
        .status.active { background: #4CAF50; }
        .status.inactive { background: #f44336; }
        .status.floating { background: #FFD700; color: #000; }
        .status.landed { background: #9C27B0; }
        .info {
            margin: 5px 0;
            font-size: 14px;
        }
        .instructions {
            margin-top: 15px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div class="ui-overlay">
        <h3 style="margin: 0 0 15px 0; color: #667eea;">üöÄ Rocket Flight VR - OOP</h3>
        <div id="status" class="status inactive">Razzi: SPENTI</div>
        <div id="position" class="info">Posizione: Y: 1.60</div>
        <div id="velocity" class="info">Velocit√†: 0.00</div>
        <div id="platform" class="info">Piattaforma: Nessuna</div>
        <button id="enterVRBtn" style="
            background: #667eea; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 8px; 
            margin: 10px 0; 
            cursor: pointer;
            font-weight: bold;
        ">Enter VR</button>
        <div class="instructions">
            <strong>Controlli Quest 3:</strong><br>
            ‚Ä¢ <strong>Tasto A:</strong> Attiva razzi (salita)<br>
            ‚Ä¢ <strong>Thumbstick sinistro:</strong> Movimento laterale<br>
            ‚Ä¢ <strong>Touch A:</strong> Fluttuazione<br>
            ‚Ä¢ <strong>Rilascio A:</strong> Gravit√† (discesa)
        </div>
    </div>

    <script>
        /**
         * CLASSE PRINCIPALE: Gestisce l'intera applicazione VR
         * Responsabilit√†: Coordinare tutti i componenti del sistema
         */
        class RocketFlightVR {
            constructor() {
                this.canvas = document.getElementById("renderCanvas");
                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = null;
                this.xr = null;
                this.gameManager = null;
                this.uiManager = null;
                this.physicsManager = null;
                this.particleManager = null;
                this.platformManager = null;
                this.controllerManager = null;
            }

            /**
             * Metodo principale per inizializzare l'applicazione
             * Sequenza: Verifica WebXR ‚Üí Crea scena ‚Üí Inizializza componenti ‚Üí Avvia loop
             */
            async initialize() {
                console.log("üöÄ Inizializzazione Rocket Flight VR...");
                
                // Verifica supporto WebXR
                if (!await this.checkWebXRSupport()) {
                    this.showError("WebXR non supportato su questo dispositivo");
                    return;
                }

                // Crea la scena principale
                this.scene = await this.createScene();
                
                // Inizializza tutti i manager
                await this.initializeManagers();
                
                // Avvia il loop di rendering
                this.startRenderLoop();
                
                console.log("‚úÖ Rocket Flight VR inizializzato con successo");
            }

            /**
             * Verifica il supporto WebXR per il dispositivo corrente
             * @returns {Promise<boolean>} True se WebXR √® supportato
             */
            async checkWebXRSupport() {
                console.log("üîç Verifica supporto WebXR...");
                
                if (!navigator.xr) {
                    console.error("‚ùå navigator.xr non disponibile");
                    return false;
                }

                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-vr');
                    console.log(`‚úÖ WebXR immersive-vr supportato: ${supported}`);
                    return supported;
                } catch (error) {
                    console.error("‚ùå Errore nel controllo WebXR:", error);
                    return false;
                }
            }

            /**
             * Crea la scena 3D principale con camera, luci e configurazioni base
             * @returns {Promise<BABYLON.Scene>} La scena creata
             */
            async createScene() {
                console.log("üé¨ Creazione scena 3D...");
                
                const scene = new BABYLON.Scene(this.engine);
                scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.1);

                // Camera principale (fallback per modalit√† desktop)
                const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1.6, 0), scene);
                camera.setTarget(BABYLON.Vector3.Zero());

                // Sistema di illuminazione
                this.setupLighting(scene);

                // Terreno base
                this.createGround(scene);

                console.log("‚úÖ Scena 3D creata");
                return scene;
            }

            /**
             * Configura il sistema di illuminazione della scena
             * @param {BABYLON.Scene} scene - La scena da illuminare
             */
            setupLighting(scene) {
                // Luce emisferica per illuminazione ambientale
                const ambientLight = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
                ambientLight.intensity = 0.7;
                
                // Luce direzionale per ombre e profondit√†
                const directionalLight = new BABYLON.DirectionalLight("directional", new BABYLON.Vector3(0, -1, 0), scene);
                directionalLight.intensity = 0.5;
                
                console.log("üí° Sistema di illuminazione configurato");
            }

            /**
             * Crea il terreno base dell'ambiente
             * @param {BABYLON.Scene} scene - La scena dove creare il terreno
             */
            createGround(scene) {
                const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
                const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
                groundMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.3);
                ground.material = groundMaterial;
                
                console.log("üåç Terreno creato");
            }

            /**
             * Inizializza tutti i manager del sistema
             * Ogni manager gestisce una specifica funzionalit√†
             */
            async initializeManagers() {
                console.log("‚öôÔ∏è Inizializzazione manager...");

                // Inizializza WebXR
                await this.initializeWebXR();

                // Crea i manager in ordine di dipendenza
                this.uiManager = new UIManager();
                this.physicsManager = new PhysicsManager();
                this.particleManager = new ParticleManager(this.scene);
                this.platformManager = new PlatformManager(this.scene);
                this.controllerManager = new ControllerManager(this.xr, this.physicsManager);
                this.gameManager = new GameManager(
                    this.physicsManager, 
                    this.particleManager, 
                    this.platformManager, 
                    this.uiManager
                );

                // Collega i manager tra loro
                this.connectManagers();
                
                // Passa il riferimento XR al game manager
                this.gameManager.setXRReference(this.xr);

                console.log("‚úÖ Tutti i manager inizializzati");
            }

            /**
             * Inizializza il sistema WebXR per la realt√† virtuale
             */
            async initializeWebXR() {
                console.log("ü•Ω Inizializzazione WebXR...");
                
                try {
                    this.xr = await this.scene.createDefaultXRExperienceAsync({
                        uiOptions: {
                            sessionMode: "immersive-vr",
                            referenceSpaceType: "local-floor"
                        },
                        optionalFeatures: ["hand-tracking", "layers", "dom-overlay"],
                        requiredFeatures: ["local-floor"]
                    });
                } catch (error) {
                    console.warn("‚ö†Ô∏è Fallback a configurazione WebXR minima:", error);
                    this.xr = await this.scene.createDefaultXRExperienceAsync({
                        uiOptions: { sessionMode: "immersive-vr" }
                    });
                }

                if (!this.xr.baseExperience) {
                    throw new Error("WebXR non inizializzato correttamente");
                }

                // Gestione stati WebXR
                this.xr.baseExperience.onStateChangedObservable.add((state) => {
                    this.uiManager.updateVRState(state);
                });

                console.log("‚úÖ WebXR inizializzato");
            }

            /**
             * Collega i manager tra loro per la comunicazione
             */
            connectManagers() {
                // Il controller manager notifica il game manager degli eventi
                this.controllerManager.onRocketStateChanged.add((state) => {
                    this.gameManager.handleRocketStateChange(state);
                });

                // Il physics manager notifica il game manager delle collisioni
                this.physicsManager.onPlatformCollision.add((platform) => {
                    this.gameManager.handlePlatformCollision(platform);
                });
            }

            /**
             * Avvia il loop di rendering principale
             */
            startRenderLoop() {
                this.engine.runRenderLoop(() => {
                    this.scene.render();
                });

                // Gestione resize della finestra
                window.addEventListener("resize", () => {
                    this.engine.resize();
                });

                console.log("üîÑ Loop di rendering avviato");
            }

            /**
             * Mostra un errore all'utente
             * @param {string} message - Messaggio di errore
             */
            showError(message) {
                console.error("‚ùå Errore:", message);
                document.getElementById('status').textContent = message;
                document.getElementById('status').className = "status inactive";
            }
        }

        /**
         * CLASSE: Gestisce l'interfaccia utente e i feedback visivi
         * Responsabilit√†: Aggiornare UI, mostrare stati, gestire feedback
         */
        class UIManager {
            constructor() {
                this.statusElement = document.getElementById('status');
                this.positionElement = document.getElementById('position');
                this.velocityElement = document.getElementById('velocity');
                this.platformElement = document.getElementById('platform');
                this.enterVRBtn = document.getElementById('enterVRBtn');
                
                this.setupEnterVRButton();
            }

            /**
             * Configura il pulsante Enter VR
             */
            setupEnterVRButton() {
                if (this.enterVRBtn) {
                    this.enterVRBtn.addEventListener('click', () => {
                        this.enterVR();
                    });
                }
            }

            /**
             * Tenta di entrare in modalit√† VR
             */
            async enterVR() {
                try {
                    console.log("üéÆ Tentativo di entrare in VR...");
                    // Questa funzione sar√† implementata dal game manager
                } catch (error) {
                    console.error("‚ùå Errore nell'entrare in VR:", error);
                    this.updateStatus("Errore VR: " + error.message, "inactive");
                }
            }

            /**
             * Aggiorna lo stato principale dell'UI
             * @param {string} text - Testo da mostrare
             * @param {string} className - Classe CSS per il colore
             */
            updateStatus(text, className) {
                this.statusElement.textContent = text;
                this.statusElement.className = `status ${className}`;
            }

            /**
             * Aggiorna le informazioni di posizione e velocit√†
             * @param {Object} position - Posizione corrente
             * @param {number} velocity - Velocit√† corrente
             * @param {string} platformName - Nome piattaforma corrente
             */
            updateInfo(position, velocity, platformName) {
                this.positionElement.textContent = `Posizione: Y: ${position.y.toFixed(2)}`;
                this.velocityElement.textContent = `Velocit√†: ${velocity.toFixed(2)}`;
                this.platformElement.textContent = `Piattaforma: ${platformName || 'Nessuna'}`;
            }

            /**
             * Aggiorna lo stato VR nell'interfaccia
             * @param {BABYLON.WebXRState} state - Stato WebXR corrente
             */
            updateVRState(state) {
                console.log("üîÑ Stato WebXR:", state);
                
                switch (state) {
                    case BABYLON.WebXRState.ENTERING_XR:
                        this.updateStatus("Entrando in VR...", "active");
                        break;
                    case BABYLON.WebXRState.IN_XR:
                        this.updateStatus("VR ATTIVO - Premi A per volare", "active");
                        break;
                    case BABYLON.WebXRState.EXITING_XR:
                        this.updateStatus("Uscendo da VR", "inactive");
                        break;
                    case BABYLON.WebXRState.NOT_IN_XR:
                        this.updateStatus("Clicca 'Enter VR' per iniziare", "inactive");
                        break;
                }
            }
        }

        /**
         * CLASSE: Gestisce la fisica del volo e il movimento
         * Responsabilit√†: Calcoli fisici, gravit√†, velocit√†, collisioni
         */
        class PhysicsManager {
            constructor() {
                // Parametri fisici del volo
                this.gravity = -0.12;
                this.thrustForce = 0.20;
                this.maxHorizontalSpeed = 0.35;
                
                // Stato fisico corrente
                this.verticalVelocity = 0;
                this.horizontalVelocity = 0;
                
                // Eventi per notificare altri componenti
                this.onPlatformCollision = new BABYLON.Observable();
                
                console.log("‚öôÔ∏è Physics Manager inizializzato");
            }

            /**
             * Applica la fisica del volo
             * @param {Object} flightState - Stato del volo (rocketActive, isFloating)
             * @param {BABYLON.Vector3} currentPosition - Posizione corrente
             * @returns {BABYLON.Vector3} Nuova posizione calcolata
             */
            applyPhysics(flightState, currentPosition) {
                // Fisica verticale
                if (flightState.rocketActive) {
                    this.verticalVelocity = this.thrustForce; // Salita costante
                } else if (flightState.isFloating) {
                    this.verticalVelocity = 0; // Fluttuazione
                } else {
                    this.verticalVelocity += this.gravity; // Gravit√†
                }

                // Calcola nuova posizione
                const newY = currentPosition.y + this.verticalVelocity;
                const newX = currentPosition.x + this.horizontalVelocity;
                const newZ = currentPosition.z;

                return new BABYLON.Vector3(newX, newY, newZ);
            }

            /**
             * Imposta la velocit√† orizzontale dal thumbstick
             * @param {number} x - Valore X del thumbstick (-1 a 1)
             */
            setHorizontalVelocity(x) {
                this.horizontalVelocity = x * this.maxHorizontalSpeed;
            }

            /**
             * Resetta tutte le velocit√† (usato per atterraggio)
             */
            resetVelocities() {
                this.verticalVelocity = 0;
                this.horizontalVelocity = 0;
            }

            /**
             * Controlla se la posizione √® sopra il terreno minimo
             * @param {BABYLON.Vector3} position - Posizione da controllare
             * @returns {BABYLON.Vector3} Posizione corretta
             */
            enforceGroundLimit(position) {
                const minY = 0.5;
                if (position.y < minY) {
                    position.y = minY;
                    this.resetVelocities();
                }
                return position;
            }

            /**
             * Ottiene lo stato fisico corrente
             * @returns {Object} Stato fisico con velocit√† e parametri
             */
            getPhysicsState() {
                return {
                    verticalVelocity: this.verticalVelocity,
                    horizontalVelocity: this.horizontalVelocity,
                    gravity: this.gravity,
                    thrustForce: this.thrustForce
                };
            }
        }

        /**
         * CLASSE: Gestisce il sistema di particelle per i razzi
         * Responsabilit√†: Creare, animare e posizionare le particelle
         */
        class ParticleManager {
            constructor(scene) {
                this.scene = scene;
                this.leftRocketParticles = null;
                this.rightRocketParticles = null;
                
                this.createParticleSystems();
                console.log("‚ú® Particle Manager inizializzato");
            }

            /**
             * Crea i sistemi di particelle per entrambi i razzi
             */
            createParticleSystems() {
                // Particelle per razzo sinistro
                this.leftRocketParticles = this.createRocketParticleSystem("leftRocketParticles");
                
                // Particelle per razzo destro
                this.rightRocketParticles = this.createRocketParticleSystem("rightRocketParticles");
            }

            /**
             * Crea un singolo sistema di particelle per un razzo
             * @param {string} name - Nome del sistema di particelle
             * @returns {BABYLON.ParticleSystem} Sistema di particelle creato
             */
            createRocketParticleSystem(name) {
                const particleSystem = new BABYLON.ParticleSystem(name, 100, this.scene);
                
                // Texture delle particelle (punto bianco)
                particleSystem.particleTexture = new BABYLON.Texture(
                    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==", 
                    this.scene
                );
                
                // Configurazione emissione
                particleSystem.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1);
                particleSystem.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);
                
                // Colori delle particelle (rosso ‚Üí arancione)
                particleSystem.color1 = new BABYLON.Color4(1, 0.2, 0.2, 1);
                particleSystem.color2 = new BABYLON.Color4(1, 0.5, 0.5, 1);
                
                // Dimensioni delle particelle
                particleSystem.minSize = 0.1;
                particleSystem.maxSize = 0.3;
                
                // Durata di vita delle particelle
                particleSystem.minLifeTime = 0.3;
                particleSystem.maxLifeTime = 0.8;
                
                // Tasso di emissione
                particleSystem.emitRate = 50;
                
                // Gravit√† delle particelle (cadono verso il basso)
                particleSystem.gravity = new BABYLON.Vector3(0, -2, 0);
                
                // Direzione di emissione
                particleSystem.direction1 = new BABYLON.Vector3(-0.5, -1, -0.5);
                particleSystem.direction2 = new BABYLON.Vector3(0.5, -1, 0.5);
                
                // Potenza di emissione
                particleSystem.minEmitPower = 1;
                particleSystem.maxEmitPower = 3;
                
                // Velocit√† di aggiornamento
                particleSystem.updateSpeed = 0.016;
                
                // Inizia fermo
                particleSystem.stop();
                
                return particleSystem;
            }

            /**
             * Attiva le particelle per un razzo specifico
             * @param {string} hand - Mano del controller ('left' o 'right')
             */
            activateRocket(hand) {
                const particleSystem = hand === 'left' ? this.leftRocketParticles : this.rightRocketParticles;
                if (particleSystem) {
                    particleSystem.start();
                }
            }

            /**
             * Disattiva le particelle per un razzo specifico
             * @param {string} hand - Mano del controller ('left' o 'right')
             */
            deactivateRocket(hand) {
                const particleSystem = hand === 'left' ? this.leftRocketParticles : this.rightRocketParticles;
                if (particleSystem) {
                    particleSystem.stop();
                }
            }

            /**
             * Aggiorna la posizione delle particelle in base alla posizione della camera
             * @param {BABYLON.Vector3} cameraPosition - Posizione della camera
             */
            updateParticlePositions(cameraPosition) {
                // Posizione particelle razzo sinistro
                if (this.leftRocketParticles) {
                    this.leftRocketParticles.emitter = cameraPosition.add(new BABYLON.Vector3(-0.3, -0.5, 0));
                }
                
                // Posizione particelle razzo destro
                if (this.rightRocketParticles) {
                    this.rightRocketParticles.emitter = cameraPosition.add(new BABYLON.Vector3(0.3, -0.5, 0));
                }
            }
        }

        /**
         * CLASSE: Gestisce le piattaforme di atterraggio
         * Responsabilit√†: Creare piattaforme, rilevare collisioni, gestire atterraggi
         */
        class PlatformManager {
            constructor(scene) {
                this.scene = scene;
                this.platforms = [];
                this.landingThreshold = 0.6;
                
                this.createPlatforms();
                console.log("üèóÔ∏è Platform Manager inizializzato");
            }

            /**
             * Crea tutte le piattaforme dell'ambiente
             */
            createPlatforms() {
                const platformData = [
                    { position: new BABYLON.Vector3(0, 2, 0), size: 10, color: new BABYLON.Color3(0.2, 0.6, 1.0), name: "Piattaforma Blu" },
                    { position: new BABYLON.Vector3(-15, 4, 0), size: 8, color: new BABYLON.Color3(1.0, 0.6, 0.0), name: "Piattaforma Arancione" },
                    { position: new BABYLON.Vector3(15, 6, 0), size: 8, color: new BABYLON.Color3(0.6, 0.2, 1.0), name: "Piattaforma Viola" },
                    { position: new BABYLON.Vector3(0, 8, 0), size: 6, color: new BABYLON.Color3(1.0, 0.2, 0.6), name: "Piattaforma Rosa" }
                ];

                platformData.forEach((data, index) => {
                    const platform = this.createPlatform(data, index);
                    this.platforms.push(platform);
                });
            }

            /**
             * Crea una singola piattaforma
             * @param {Object} data - Dati della piattaforma
             * @param {number} index - Indice della piattaforma
             * @returns {Object} Oggetto piattaforma con mesh e metadati
             */
            createPlatform(data, index) {
                // Crea la mesh della piattaforma
                const platformMesh = BABYLON.MeshBuilder.CreateBox(`platform${index}`, { 
                    width: data.size, 
                    height: 1, 
                    depth: data.size 
                }, this.scene);
                
                // Posiziona la piattaforma
                platformMesh.position = data.position;
                
                // Crea il materiale colorato
                const platformMaterial = new BABYLON.StandardMaterial(`platformMat${index}`, this.scene);
                platformMaterial.diffuseColor = data.color;
                platformMesh.material = platformMaterial;
                
                // Restituisce oggetto con mesh e metadati
                return {
                    mesh: platformMesh,
                    y: data.position.y,
                    name: data.name,
                    color: data.color
                };
            }

            /**
             * Controlla se la posizione √® vicina a una piattaforma
             * @param {number} currentY - Posizione Y corrente
             * @returns {Object|null} Piattaforma se in prossimit√†, null altrimenti
             */
            checkPlatformLanding(currentY) {
                for (let platform of this.platforms) {
                    const distance = Math.abs(currentY - platform.y);
                    if (distance <= this.landingThreshold) {
                        return platform;
                    }
                }
                return null;
            }

            /**
             * Ottiene tutte le piattaforme
             * @returns {Array} Array delle piattaforme
             */
            getPlatforms() {
                return this.platforms;
            }
        }

        /**
         * CLASSE: Gestisce i controller VR e i loro input
         * Responsabilit√†: Rilevare input controller, gestire eventi, notificare altri componenti
         */
        class ControllerManager {
            constructor(xr, physicsManager) {
                this.xr = xr;
                this.physicsManager = physicsManager;
                this.controllers = new Map(); // Mappa controller per mano
                
                // Eventi per notificare altri componenti
                this.onRocketStateChanged = new BABYLON.Observable();
                
                this.setupControllers();
                console.log("üéÆ Controller Manager inizializzato");
            }

            /**
             * Configura i controller e i loro eventi
             */
            setupControllers() {
                this.xr.input.onControllerAddedObservable.add(controller => {
                    this.handleControllerAdded(controller);
                });
            }

            /**
             * Gestisce l'aggiunta di un nuovo controller
             * @param {Object} controller - Controller aggiunto
             */
            handleControllerAdded(controller) {
                const handedness = controller.inputSource.handedness;
                console.log(`üéÆ Controller ${handedness} aggiunto`);
                
                this.controllers.set(handedness, controller);
                
                controller.onMotionControllerInitObservable.add(motionController => {
                    this.setupControllerEvents(motionController, handedness);
                });
            }

            /**
             * Configura gli eventi per un controller specifico
             * @param {Object} motionController - Controller motion
             * @param {string} handedness - Mano del controller ('left' o 'right')
             */
            setupControllerEvents(motionController, handedness) {
                console.log(`‚öôÔ∏è Configurazione eventi controller ${handedness}`);
                
                // Gestione tasto A per entrambi i controller
                this.setupAButton(motionController, handedness);
                
                // Gestione touch per fluttuazione
                this.setupTouchEvents(motionController, handedness);
                
                // Gestione thumbstick solo per controller sinistro
                if (handedness === 'left') {
                    this.setupThumbstick(motionController);
                }
            }

            /**
             * Configura gli eventi del tasto A
             * @param {Object} motionController - Controller motion
             * @param {string} handedness - Mano del controller
             */
            setupAButton(motionController, handedness) {
                const aButton = motionController.getComponent('a-button');
                if (aButton) {
                    aButton.onButtonStateChangedObservable.add(() => {
                        if (aButton.pressed) {
                            console.log(`üî• Tasto A premuto su ${handedness}`);
                            this.onRocketStateChanged.notifyObservers({
                                type: 'rocket_activated',
                                hand: handedness
                            });
                        } else {
                            console.log(`üí® Tasto A rilasciato su ${handedness}`);
                            this.onRocketStateChanged.notifyObservers({
                                type: 'rocket_deactivated',
                                hand: handedness
                            });
                        }
                    });
                }
            }

            /**
             * Configura gli eventi touch per fluttuazione
             * @param {Object} motionController - Controller motion
             * @param {string} handedness - Mano del controller
             */
            setupTouchEvents(motionController, handedness) {
                const aButtonTouch = motionController.getComponent('a-button-touch');
                if (aButtonTouch) {
                    aButtonTouch.onButtonStateChangedObservable.add(() => {
                        if (aButtonTouch.pressed) {
                            console.log(`üïäÔ∏è Touch A su ${handedness} - Fluttuazione`);
                            this.onRocketStateChanged.notifyObservers({
                                type: 'floating_started',
                                hand: handedness
                            });
                        } else {
                            this.onRocketStateChanged.notifyObservers({
                                type: 'floating_stopped',
                                hand: handedness
                            });
                        }
                    });
                }
            }

            /**
             * Configura gli eventi del thumbstick per movimento laterale
             * @param {Object} motionController - Controller motion
             */
            setupThumbstick(motionController) {
                const thumbstick = motionController.getComponent('thumbstick');
                if (thumbstick) {
                    thumbstick.onButtonStateChangedObservable.add(() => {
                        const x = thumbstick.xAxis.value;
                        this.physicsManager.setHorizontalVelocity(x);
                    });
                }
            }
        }

        /**
         * CLASSE: Gestisce la logica di gioco principale
         * Responsabilit√†: Coordinare tutti i manager, gestire stati di gioco, aggiornare UI
         */
        class GameManager {
            constructor(physicsManager, particleManager, platformManager, uiManager) {
                this.physicsManager = physicsManager;
                this.particleManager = particleManager;
                this.platformManager = platformManager;
                this.uiManager = uiManager;
                
                // Stato del gioco
                this.gameState = {
                    rocketActive: false,
                    isFloating: false,
                    currentPlatform: null
                };
                
                // Riferimento alla camera attiva
                this.activeCamera = null;
                
                // Riferimento al sistema XR
                this.xr = null;
                
                console.log("üéØ Game Manager inizializzato");
            }

            /**
             * Imposta la camera attiva per il gioco
             * @param {BABYLON.Camera} camera - Camera da usare
             */
            setActiveCamera(camera) {
                this.activeCamera = camera;
            }

            /**
             * Imposta il riferimento al sistema XR
             * @param {Object} xr - Sistema XR
             */
            setXRReference(xr) {
                this.xr = xr;
            }

            /**
             * Gestisce i cambiamenti di stato dei razzi
             * @param {Object} stateChange - Cambio di stato
             */
            handleRocketStateChange(stateChange) {
                switch (stateChange.type) {
                    case 'rocket_activated':
                        this.gameState.rocketActive = true;
                        this.gameState.isFloating = false;
                        this.particleManager.activateRocket(stateChange.hand);
                        this.uiManager.updateStatus("Razzi: ATTIVI", "active");
                        break;
                        
                    case 'rocket_deactivated':
                        this.gameState.rocketActive = false;
                        this.gameState.isFloating = false;
                        this.particleManager.deactivateRocket(stateChange.hand);
                        this.uiManager.updateStatus("Razzi: SPENTI", "inactive");
                        break;
                        
                    case 'floating_started':
                        this.gameState.isFloating = true;
                        this.gameState.rocketActive = false;
                        this.uiManager.updateStatus("FLUTTUAZIONE", "floating");
                        break;
                        
                    case 'floating_stopped':
                        this.gameState.isFloating = false;
                        break;
                }
            }

            /**
             * Gestisce le collisioni con le piattaforme
             * @param {Object} platform - Piattaforma con cui si √® collisi
             */
            handlePlatformCollision(platform) {
                this.gameState.currentPlatform = platform;
                this.physicsManager.resetVelocities();
                this.uiManager.updateStatus(`Atterrato su ${platform.name}`, "landed");
            }

            /**
             * Aggiorna il gioco (chiamato ogni frame)
             * @param {BABYLON.Scene} scene - Scena corrente
             */
            update(scene) {
                if (!this.activeCamera) {
                    return;
                }

                // Determina se siamo in VR e ottieni il rig corretto
                const isInVR = this.xr && this.xr.baseExperience && this.xr.baseExperience.state === BABYLON.WebXRState.IN_XR;
                let cameraRig;
                
                if (isInVR && this.xr.baseExperience.camera && this.xr.baseExperience.camera.parent) {
                    // In VR: muovi il rig per mantenere il tracking posizionale
                    cameraRig = this.xr.baseExperience.camera.parent;
                } else {
                    // Fuori VR: muovi la camera normale
                    cameraRig = this.activeCamera;
                }
                
                if (!cameraRig) {
                    console.warn("‚ö†Ô∏è Nessuna camera disponibile per il movimento");
                    return;
                }
                
                const currentPosition = cameraRig.position;
                
                // Controlla collisioni con piattaforme
                const landingPlatform = this.platformManager.checkPlatformLanding(currentPosition.y);
                
                // Applica fisica
                const newPosition = this.physicsManager.applyPhysics(this.gameState, currentPosition);
                
                // Gestione atterraggio automatico
                if (landingPlatform && this.physicsManager.verticalVelocity <= 0) {
                    newPosition.y = landingPlatform.y;
                    this.handlePlatformCollision(landingPlatform);
                }
                
                // Applica limite terreno
                const finalPosition = this.physicsManager.enforceGroundLimit(newPosition);
                
                // Aggiorna posizione del rig (non della camera singola)
                try {
                    cameraRig.position = finalPosition;
                } catch (error) {
                    console.error("‚ùå Errore nell'aggiornamento posizione:", error);
                    // Fallback: prova a muovere la camera normale
                    if (this.activeCamera) {
                        this.activeCamera.position = finalPosition;
                    }
                }
                
                // Aggiorna UI
                const physicsState = this.physicsManager.getPhysicsState();
                this.uiManager.updateInfo(
                    { y: finalPosition.y }, 
                    physicsState.verticalVelocity, 
                    landingPlatform ? landingPlatform.name : null
                );
                
                // Aggiorna posizione particelle
                if (this.gameState.rocketActive) {
                    this.particleManager.updateParticlePositions(finalPosition);
                }
            }
        }

        // INIZIALIZZAZIONE DELL'APPLICAZIONE
        // Crea e avvia l'applicazione quando il DOM √® caricato
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("üöÄ Avvio Rocket Flight VR...");
            
            try {
                const app = new RocketFlightVR();
                await app.initialize();
                
                // Configura il game manager con la camera e XR
                if (app.gameManager && app.scene) {
                    app.gameManager.setActiveCamera(app.scene.activeCamera);
                    app.gameManager.setXRReference(app.xr);
                    
                    // Registra il loop di aggiornamento del gioco
                    app.scene.registerBeforeRender(() => {
                        app.gameManager.update(app.scene);
                    });
                }
                
            } catch (error) {
                console.error("‚ùå Errore nell'inizializzazione:", error);
                document.getElementById('status').textContent = "Errore: " + error.message;
            }
        });
    </script>
</body>
</html> 